/**
 * @fileoverview Google Gemini API Integration for Technical Documentation Generation
 * @module services/geminiService
 * @description Uses REST API with fetchWithRetry for robustness
 */

import { fetchWithRetry } from '../src/lib/http.js';
import { env } from '../src/config/index.js';

const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';

/**
 * @async
 * @function generateDocumentation
 * @description Generates technical documentation in English using Gemini API with 5-section structure
 * @param {Object} input - The input data (accepts any language input)
 * @param {string} input.context - Context of the task (required)
 * @param {string} input.code - Code implementation (optional)
 * @param {string} input.challenges - Challenges/difficulties faced (optional)
 * @returns {Promise<string>} Generated documentation in English Markdown format
 * @throws {Error} When API key is missing, API request fails, or response is invalid
 */
export async function generateDocumentation({ context, code, challenges }) {
  const model = env.GEMINI_MODEL;
  const apiKey = env.GEMINI_API_KEY;

  const prompt = buildPrompt(context, code, challenges);
  const systemInstruction = getSystemInstruction();

  try {
    const response = await fetchWithRetry(
      `${GEMINI_API_BASE}/${model}:generateContent?key=${apiKey}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              role: 'user',
              parts: [{ text: prompt }],
            },
          ],
          systemInstruction: {
            parts: [{ text: systemInstruction }],
          },
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 4096,
            topP: 0.8,
            topK: 40,
          },
        }),
        timeoutMs: 60000,
        attempts: 3,
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('Gemini API error:', errorData);
      throw new Error(
        `Gemini API failed: ${response.status} - ${
          errorData.error?.message || 'Unknown error'
        }`
      );
    }

    const data = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No content generated by Gemini');
    }

    const candidate = data.candidates[0];
    if (!candidate.content || !candidate.content.parts) {
      throw new Error('Invalid response structure from Gemini');
    }

    const generatedText = candidate.content.parts
      .map((part) => part.text)
      .join('');

    return generatedText;
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    throw new Error(`Failed to generate documentation: ${error.message}`);
  }
}

/**
 * @function getSystemInstruction
 * @description Builds the system instruction for Gemini - sets the model's role as a Staff-level Data Engineer and Technical Communicator
 * @returns {string} System instruction text in English
 */
function getSystemInstruction() {
  return `You are a Staff-level Data Engineer and expert Technical Communicator. Your job is to analyze raw task notes and transform them into clear, concise, high-quality technical documentation.

Your mission is to process three user inputs ($TASK_CONTEXT, $CODE_IMPLEMENTATION, $CHALLENGES) provided in ANY language.

Follow this 3-step process:
1. [ANALYZE & TRANSLATE]: Deeply analyze the content of all three inputs. Identify the core problem, technical solution, architectural decisions, and lessons learned. Mentally translate all content and concepts to ENGLISH.
2. [SYNTHESIZE]: Synthesize the translated information into cohesive, logical technical documentation. DO NOT just list the inputs; instead, structure the information into a narrative that explains what, why, and how.
3. [FORMAT]: Format the output as a clean, well-structured Markdown document following the required structure.

Guidelines:
- Accept input in any language but always output in ENGLISH
- Use technical but accessible language
- Be specific and detailed
- Format text in Markdown with headers, lists, and code blocks
- Maintain a professional and informative tone
- Structure content logically and hierarchically`;
}

/**
 * @function buildPrompt
 * @description Builds the user prompt for documentation generation
 * @param {string} context - Task context
 * @param {string} code - Code implementation
 * @param {string} challenges - Challenges faced
 * @returns {string} Complete prompt in English with 5-section structure
 */
function buildPrompt(context, code, challenges) {
  let prompt = `Process the following inputs and generate technical documentation:

**$TASK_CONTEXT:**
${context}
`;

  if (code && code.trim()) {
    prompt += `\n**$CODE_IMPLEMENTATION:**
\`\`\`
${code}
\`\`\`
`;
  }

  if (challenges && challenges.trim()) {
    prompt += `\n**$CHALLENGES:**
${challenges}
`;
  }

  prompt += `\n
Generate documentation following EXACTLY this structure in ENGLISH:

# [Concise and Descriptive Task Title]

## Summary
Write 1-2 sentences in English summarizing the task and its purpose.

## Problem Solved
Describe the business or technical problem that this task solved, based on the $TASK_CONTEXT.

## Solution Implemented
Describe the technical approach and key implementation decisions. If the $TASK_CONTEXT mentions why one approach was chosen over another, include that.

## Code Highlights
Instead of providing the entire code implementation, extract 2-3 SHORT, FOCUSED code snippets (5-15 lines each) that highlight:
- The main function or entry point
- Critical business logic or transformations
- Key technical decisions or patterns

For each snippet:
- Write a brief 1-sentence explanation in BOLD (wrapped in **text**)
- Include the code block immediately after with inferred language (python, sql, javascript, etc.)
- Keep snippets concise and meaningful

Example format:
**Brief explanation of first snippet.**

\`\`\`python
code here
\`\`\`

**Brief explanation of second snippet.**

\`\`\`sql
code here
\`\`\`

DO NOT include the full $CODE_IMPLEMENTATION. Extract only the most important parts that demonstrate the solution approach.

## Challenges & Learnings
Based on the $CHALLENGES, list the main obstacles or insights as bullet points.

- First challenge or lesson learned.
- Second challenge or lesson learned.

**Important:**
- Output MUST be 100% in ENGLISH
- Use Markdown with ## for main sections
- Include bulleted lists (-) when appropriate
- Be detailed and specific in each section
- Infer and specify the code language in code blocks (e.g., \`\`\`python, \`\`\`sql, \`\`\`javascript)
- Maintain technical focus with clarity`;

  return prompt;
}

/**
 * @async
 * @function generateArchitectureDocumentation
 * @description Generates architecture documentation in English using Gemini API with 6-section structure
 * @param {Object} input - The architecture input data (accepts any language input)
 * @param {string} input.overview - Overview & components description
 * @param {string} input.dataflow - Data flow & technology stack description
 * @param {string} input.decisions - Design decisions & trade-offs description
 * @returns {Promise<string>} Generated architecture documentation in English Markdown format
 * @throws {Error} When API key is missing, API request fails, or response is invalid
 */
export async function generateArchitectureDocumentation({ overview, dataflow, decisions }) {
  const model = env.GEMINI_MODEL;
  const apiKey = env.GEMINI_API_KEY;

  const prompt = buildArchitecturePrompt(overview, dataflow, decisions);
  const systemInstruction = getArchitectureSystemInstruction();

  try {
    const response = await fetchWithRetry(
      `${GEMINI_API_BASE}/${model}:generateContent?key=${apiKey}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              role: 'user',
              parts: [{ text: prompt }],
            },
          ],
          systemInstruction: {
            parts: [{ text: systemInstruction }],
          },
          generationConfig: {
            temperature: 0.3,
            maxOutputTokens: 4096,
            topP: 0.8,
            topK: 40,
          },
        }),
        timeoutMs: 60000,
        attempts: 3,
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('Gemini API error:', errorData);
      throw new Error(
        `Gemini API failed: ${response.status} - ${
          errorData.error?.message || 'Unknown error'
        }`
      );
    }

    const data = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
      throw new Error('No content generated by Gemini');
    }

    const candidate = data.candidates[0];
    if (!candidate.content || !candidate.content.parts) {
      throw new Error('Invalid response structure from Gemini');
    }

    const generatedText = candidate.content.parts
      .map((part) => part.text)
      .join('');

    return generatedText;
  } catch (error) {
    console.error('Error calling Gemini API for architecture:', error);
    throw new Error(`Failed to generate architecture documentation: ${error.message}`);
  }
}

/**
 * @function getArchitectureSystemInstruction
 * @description Builds the system instruction for Gemini - sets the model's role as a Senior Software Architect
 * @returns {string} System instruction text in English
 */
function getArchitectureSystemInstruction() {
  return `You are a Senior Software Architect with deep expertise in system design, distributed systems, and technical communication. Your job is to analyze architecture descriptions and transform them into comprehensive, professional architecture documentation.

Your mission is to process three user inputs ($OVERVIEW_AND_COMPONENTS, $DATA_FLOW_AND_TECH_STACK, $DESIGN_DECISIONS_AND_TRADEOFFS) provided in ANY language.

Follow this 3-step process:
1. [ANALYZE & TRANSLATE]: Deeply analyze all three inputs. Identify system components, data flows, technology choices, design rationale, and trade-offs. Mentally translate all content and concepts to ENGLISH.
2. [SYNTHESIZE]: Synthesize the translated information into cohesive architecture documentation. Structure information into a clear narrative that explains the system holistically - its purpose, structure, flow, technologies, and critical decisions.
3. [FORMAT]: Format the output as a clean, well-structured Markdown document following the required 6-section structure.

Guidelines:
- Accept input in any language but always output in ENGLISH
- Use technical but accessible language appropriate for architecture docs
- Be specific about components, flows, and technologies
- Explain the "why" behind design decisions
- Be honest about trade-offs and risks
- Format text in Markdown with headers, lists, and diagrams (as ASCII or text descriptions)
- Maintain a professional, analytical, and objective tone
- Structure content logically and hierarchically
- Focus on clarity and durability - this document should remain valuable over time`;
}

/**
 * @function buildArchitecturePrompt
 * @description Builds the user prompt for architecture documentation generation
 * @param {string} overview - Overview & components description
 * @param {string} dataflow - Data flow & technology stack description
 * @param {string} decisions - Design decisions & trade-offs description
 * @returns {string} Complete prompt in English with 6-section structure
 */
function buildArchitecturePrompt(overview, dataflow, decisions) {
  let prompt = `Process the following architecture inputs and generate comprehensive architecture documentation:

**$OVERVIEW_AND_COMPONENTS:**
${overview}

**$DATA_FLOW_AND_TECH_STACK:**
${dataflow}

**$DESIGN_DECISIONS_AND_TRADEOFFS:**
${decisions}

Generate architecture documentation following EXACTLY this structure in ENGLISH:

# [System/Component Name] - Architecture

## Overview
Based on $OVERVIEW_AND_COMPONENTS, write 2-3 paragraphs in English that answer:
- What is this system/component and what is its core business purpose?
- Who are the primary users or consumers?
- What problem does it solve at a high level?

Be clear and concise. This should give readers immediate context.

## Key Components
Based on $OVERVIEW_AND_COMPONENTS and $DATA_FLOW_AND_TECH_STACK, identify and describe the main building blocks:

- **Component Name 1**: Brief description of its responsibility
- **Component Name 2**: Brief description of its responsibility
- **Component Name 3**: Brief description of its responsibility

Focus on the PRIMARY components. Avoid listing every small detail. Group related sub-components if needed.

## Data & Service Flow
Based on $DATA_FLOW_AND_TECH_STACK, describe how data and requests move through the system:

1. **Entry Point**: Where does data/requests enter the system?
2. **Processing Flow**: What are the main steps in the flow?
3. **Exit Point**: Where does data go or what is the final output?

If applicable, use a simple ASCII diagram or numbered list to show the flow clearly. Example:

\`\`\`
User Request → API Gateway → Service A → Database → Service B → Response
\`\`\`

Or use a bulleted narrative if a diagram is not practical.

## Technology Stack
Based on $DATA_FLOW_AND_TECH_STACK, list the key technologies chosen:

- **Language(s)**: Python, JavaScript, Go, etc.
- **Frameworks**: Django, React, Spring Boot, etc.
- **Databases**: PostgreSQL, MongoDB, Redis, etc.
- **Infrastructure**: Kubernetes, AWS Lambda, Docker, etc.
- **Message Queues/Streams**: Kafka, RabbitMQ, etc. (if applicable)
- **Other Tools**: Airflow, Grafana, etc. (if applicable)

Only include technologies that are actually used. Be specific (e.g., "PostgreSQL 14" not just "SQL database").

## Key Design Decisions & Rationale
Based on $DESIGN_DECISIONS_AND_TRADEOFFS, explain the most important design choices:

**Decision 1: [Title of Decision]**
- **What was chosen**: [Specific technology/pattern/approach]
- **Why it was chosen**: [Business or technical rationale]
- **Alternative considered**: [What else was considered and why it was rejected]

**Decision 2: [Title of Decision]**
- **What was chosen**: [Specific technology/pattern/approach]
- **Why it was chosen**: [Business or technical rationale]
- **Alternative considered**: [What else was considered and why it was rejected]

Focus on 2-4 critical decisions. These should be decisions that significantly impact the system's behavior, performance, cost, or maintainability.

## Risks & Trade-offs
Based on $DESIGN_DECISIONS_AND_TRADEOFFS, honestly assess known weaknesses or compromises:

- **Risk/Trade-off 1**: [Description of the risk or compromise and its potential impact]
- **Risk/Trade-off 2**: [Description of the risk or compromise and its potential impact]
- **Risk/Trade-off 3**: [Description of the risk or compromise and its potential impact]

Examples: "Eventual consistency means users may see stale data for up to 5 seconds", "No disaster recovery plan beyond daily backups", "High operational complexity due to microservices".

Be objective and factual. This section builds trust and helps future maintainers understand limitations.

**Important:**
- Output MUST be 100% in ENGLISH
- Use Markdown with ## for main sections
- Include bulleted lists (-) and bold (**text**) for emphasis
- Be detailed and specific in each section
- Use ASCII diagrams or structured text for flows
- Maintain a professional, analytical tone
- Focus on clarity, honesty, and long-term value`;

  return prompt;
}
